import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import CubicSpline

from .electron_loss import get_electron_energy_loss
from .geostat_electron_flux import geostat_electrons_spec_flux
from .refraction_index import get_refraction_index

RAD = 180.0 / np.pi  # Convert steradians to arcsec^2


class CerenkovBackground:
    """
    Calculate the Cerenkov background light generated by high-energy electrons
    in optical materials like silica or sapphire.

    This module computes the Cerenkov photon yield and angular distribution
    caused by geostationary electrons interacting with the material, using
    electron flux data (AE9 model), stopping power, and refractive index models.

    Parameters
    ----------
    material : str
        Material name ('si02_suprasil_2a', 'silica', or 'sapphire').
    flux_option : str
        Column name from the electron flux table (e.g., 'DailyMax_75Flux').
    plot : bool, optional
        If True, generate diagnostic plots when calling `evaluate()`.

    Attributes
    ----------
    lam : np.ndarray
        Wavelength array [Å].
    intensity : np.ndarray
        Cerenkov intensity spectrum [count/cm^2/s/sr/μm].
    n_arrayls
      : np.ndarray
        Refractive index array corresponding to `lam`.
    lum_array : np.ndarray
        Luminosity per wavelength bin [count/cm^2/s/μm].
    res_el : dict
        Dictionary containing electron energy ('E') and flux ('F').
    cint_data : dict
        Cumulative intensity and angle data for plotting.
    angular_data : dict
        Angular distribution data for plotting.

    References
    ----------
    This module is a Python port of the MATLAB `Cerenkov` function from the MAATv2 package:
    https://www.mathworks.com/matlabcentral/fileexchange/128984-astropack-maatv2

    It incorporates:
    - The AE9 trapped electron flux model :footcite:`2013SSRv..179..579G`.
    - Stopping power and refractive index models :footcite:`2018PASP..130g5002S, 2019PASP..131e4504O`.
    - The conservative noise modeling approach from ULTRASAT :footcite:`2024ApJ...964...74S`.
    - Zodiacal light background reference :footcite:`1998A&AS..127....1L`.

    .. footbibliography::

    Examples
    --------
    >>> from m4opt.synphot.background import CerenkovBackground
    >>> cerenkov = CerenkovBackground(material='si02_suprasil_2a', plot=False)
    >>> result, res_el = cerenkov.evaluate()
    >>> cerenkov.plot()
    >>> cerenkov.plot_flux()
    >>> cerenkov.plot_cumulative_energy()
    >>> cerenkov.plot_angular_distribution()

    .. plot::
    :caption: Cerenkov intensity vs. wavelength

    from cerenkov_background import CerenkovBackground
    cerenkov = CerenkovBackground(material='si02_suprasil_2a')
    cerenkov.evaluate()
    cerenkov.plot()
    """

    def __init__(
        self, material="si02_suprasil_2a", flux_option="DailyMax_75Flux", plot=False
    ):
        self.material = material.lower()
        self.flux_option = flux_option
        self.enable_plot = plot
        self.lam = None
        self.intensity = None
        self.n_array = None
        self.lum_array = None
        self.res_el = None
        self.cint_data = None
        self.angular_data = None

        # Kruk et al. reference, figure 6
        self.F = 10 ** np.array([9, 8, 7, 6, 4, 1])
        self.Ee = np.array([0.001, 0.05, 0.25, 0.7, 2.5, 8])

    def evaluate(self):
        # Set material properties
        if self.material in ["silica", "sio2", "si02_suprasil_2a"]:
            n_val, rho = 1.5, 2.2
        elif self.material == "sapphire":
            n_val, rho = 1.75, 4.0
        else:
            raise ValueError("Unknown material option")

        # 1. Retrieve electron flux data (AE9 model)
        flux_data = geostat_electrons_spec_flux(source="AE9")
        column_names = flux_data["columns"][1:]
        Ee1 = flux_data["data"]["Energy"]
        F1 = flux_data["data"][self.flux_option]
        self.res_el = {"E": Ee1, "F": F1}

        if self.enable_plot:
            self._plot_flux(Ee1, flux_data, column_names)

        # 2. Interpolate over a finer energy grid
        ee = np.logspace(np.log10(0.04), np.log10(8), 1000)
        cs_flux = CubicSpline(Ee1, F1, bc_type="natural", extrapolate=True)
        Fe = cs_flux(ee)

        em = 0.5 * (ee[:-1] + ee[1:])
        gm = 1 + em / 0.511
        bm = np.sqrt(1 - 1.0 / gm**2)
        ge = 1 + ee / 0.511
        be = np.sqrt(1 - 1 / ge**2)

        cs_fm = CubicSpline(ee, Fe, bc_type="natural", extrapolate=True)
        Fm = cs_fm(em)

        fC = np.maximum(0, 1 - 1.0 / n_val**2 / bm**2)

        # 3. Calculate dE/dX (energy loss)
        Ek, dEdX = get_electron_energy_loss(self.material, self.enable_plot)
        cs_dEdX = CubicSpline(Ek, 1.0 / dEdX, bc_type="natural", extrapolate=True)
        gEE = cs_dEdX(em)

        intg = gEE * Fm * fC
        cs_intg = CubicSpline(em, intg, bc_type="natural", extrapolate=True)

        # the = np.arccos(1 / n_val / be)
        the_arg = np.clip(1 / n_val / be, -1.0, 1.0)
        the = np.arccos(the_arg)

        FlagReal = np.imag(the) == 0
        Cint = np.concatenate(([0], np.cumsum(intg * np.diff(ee)))) / np.sum(
            intg * np.diff(ee)
        )

        self.cint_data = {"ee": ee, "Cint": Cint, "the": the, "FlagReal": FlagReal}

        thM = np.arccos(1.0 / n_val)
        th = thM * 10 ** np.arange(-2, 0.01, 0.01)
        thm = 0.5 * (th[:-1] + th[1:])
        bth = 1.0 / n_val / np.cos(thm)
        gth = 1.0 / np.sqrt(1 - bth**2)
        eth = 0.511 * (gth - 1)

        gEE_eth = cs_dEdX(eth)
        cs_gEE = CubicSpline(eth, gEE_eth, bc_type="natural", extrapolate=True)
        int_qC = (
            cs_fm(eth)
            / cs_fm(1)
            * (gth * bth) ** 3
            * np.sin(thm) ** 3
            * gEE_eth
            / cs_gEE(1)
        )
        qCth = int_qC * np.diff(th)
        # ICth = np.concatenate(([0], np.cumsum(int_qC * np.diff(th)))) / qCth

        # Pad qCth to match cumulative sum length
        qCth_padded = np.concatenate(([0], qCth))
        # ICth = np.concatenate(([0], np.cumsum(int_qC * np.diff(th)))) / qCth_padded
        qCth_padded_safe = np.where(qCth_padded == 0, np.nan, qCth_padded)
        ICth = np.concatenate(([0], np.cumsum(int_qC * np.diff(th)))) / qCth_padded_safe

        self.angular_data = {"th": th, "ICth": ICth, "thm": thm, "eth": eth, "thM": thM}

        # 4. Get wavelength-dependent refractive index
        Lam, n, _ = get_refraction_index(self.material)
        Nn = len(n)
        IC1mu_array = np.full(Nn, np.nan)
        L1mu_array = np.full(Nn, np.nan)

        for i in range(Nn):
            # bMi = 1 / n[i]
            # gMi = 1 / np.sqrt(1 - bMi ** 2)
            gmi = 1 + em / 0.511
            bmi = np.sqrt(1 - 1.0 / gmi**2)

            fCi = np.maximum(0, 1 - 1 / n[i] ** 2 / bmi**2)
            intg_i = gEE * Fm * fCi
            Lnorm = 2 * np.pi / 137 / rho / (1e-8 * Lam[i]) ** 2 * cs_intg(1) * 1e-4
            int_val = np.sum(intg_i * np.diff(ee)) / cs_intg(1)

            L1mu_array[i] = int_val * Lnorm
            IC1mu_array[i] = L1mu_array[i] / (2 * np.pi * n[i] ** 2)

        self.lam = Lam
        self.intensity = IC1mu_array
        self.n_array = n
        self.lum_array = L1mu_array

        result = {
            "Lam": Lam,
            "Int": IC1mu_array,
            "Int_Units": "count/cm^2/s/sr/μm",
            "IntAA": IC1mu_array / 1e4 / ((RAD * 3600) ** 2),
            "IntAA_Units": "count/cm^2/s/arcsec²/Ang",
            "Int_arcsec_Units": r"counts cm$^{-2}$ s$^{-1}$ arcsec$^{-2}$ \AA$^{-1}$",
            "IntFA_Units": "erg/cm^2/s/arcsec²/Ang",
            "n": n,
            "Lum": L1mu_array,
        }

        return result, self.res_el

    def _plot_flux(self, Ee1, flux_data, column_names):
        colors = plt.cm.viridis(np.linspace(0, 1, len(column_names)))
        plt.figure()
        plt.loglog(self.Ee, self.F, "r", label="Reference from Kruk et al.")
        for i, name in enumerate(column_names):
            plt.loglog(Ee1, flux_data["data"][name], label=name, color=colors[i])
        plt.axis([1e-2, 10, 10, 1e9])
        plt.grid(True)
        plt.legend()
        plt.xlabel("Electron Energy [MeV]")
        plt.ylabel("Flux [counts/cm^2/s]")
        plt.title("Electron Flux (AE9 Model)")
        plt.show()

    def plot(self):
        if self.lam is None or self.intensity is None:
            raise ValueError("Run evaluate() first.")
        plt.figure(figsize=(8, 5))
        plt.plot(self.lam, self.intensity)
        plt.xlabel(r"Wavelength [$\AA$]")
        plt.ylabel(r"Cerenkov Intensity [count/$cm^2$/s/sr/μm]")
        plt.title(r"Cerenkov Intensity vs. Wavelength")
        plt.grid(True)
        plt.show()

    def plot_flux(self):
        if self.res_el is None:
            raise ValueError("Run evaluate() first.")
        flux_data = geostat_electrons_spec_flux(source="AE9")
        column_names = flux_data["columns"][1:]
        self._plot_flux(self.res_el["E"], flux_data, column_names)

    def plot_cumulative_energy(self):
        if self.cint_data is None:
            raise ValueError("Run evaluate() first.")
        ee = self.cint_data["ee"]
        Cint = self.cint_data["Cint"]
        the = self.cint_data["the"]
        FlagReal = self.cint_data["FlagReal"]
        plt.figure(figsize=(8, 5))
        plt.loglog(ee[FlagReal], Cint[FlagReal], label=r"$I(<E)/I$")
        plt.loglog(ee[FlagReal], the[FlagReal], label=r"$\theta$")
        plt.axis([0.1, 3, 1e-2, 1])
        plt.grid(True)
        plt.xlabel("Energy [MeV]")
        plt.ylabel(r"$I(<E)/I, \theta$")
        plt.title("Cumulative Cerenkov Intensity and Angle vs. Energy")
        plt.legend()
        plt.show()

    def plot_angular_distribution(self):
        if self.angular_data is None:
            raise ValueError("Run evaluate() first.")
        th = self.angular_data["th"]
        ICth = self.angular_data["ICth"]
        thm = self.angular_data["thm"]
        eth = self.angular_data["eth"]
        thM = self.angular_data["thM"]
        plt.figure(figsize=(8, 5))
        plt.loglog(th, ICth, label=r"$I(<\theta)/I$")
        plt.loglog(thm, eth, "k", label=r"$E_e$ [MeV]")
        plt.loglog(th, (th / thM) ** 4, "b--", label=r"$(\theta/\theta_M)^4$")
        plt.grid(True)
        plt.axis([0.2, 1, 1e-2, 2])
        plt.xlabel(r"$\theta$")
        plt.ylabel(r"$I(<\theta)/I, E_e$ [MeV]")
        plt.title("Cerenkov Angular Distribution")
        plt.legend()
        plt.show()
